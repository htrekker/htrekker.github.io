<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Pasilo | An adventure of Internet.</title>
    <link>https://htrekker.github.io/post/</link>
    <description>Recent content in Posts on Pasilo | An adventure of Internet.</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 Mar 2020 13:14:55 +0800</lastBuildDate>
    
	<atom:link href="https://htrekker.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hugo中使用latex数学公式</title>
      <link>https://htrekker.github.io/post/math-formula-in-hugo/</link>
      <pubDate>Sun, 29 Mar 2020 13:14:55 +0800</pubDate>
      
      <guid>https://htrekker.github.io/post/math-formula-in-hugo/</guid>
      <description>&lt;p&gt;什么？在Hugo里不能愉快的使用latex？按这里👇&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 做题记录</title>
      <link>https://htrekker.github.io/post/leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 25 Dec 2019 14:57:04 +0800</pubDate>
      
      <guid>https://htrekker.github.io/post/leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;这是我的leetcode做题记录。主要用来记录做过的题和常用的算法。不定期更新&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Skip List A Brief Introduction</title>
      <link>https://htrekker.github.io/post/skiplit/</link>
      <pubDate>Wed, 25 Dec 2019 14:57:04 +0800</pubDate>
      
      <guid>https://htrekker.github.io/post/skiplit/</guid>
      <description>&lt;p&gt;听说跳表很厉害，那么&amp;hellip;一起来学学跳表吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>何为惰性求值？</title>
      <link>https://htrekker.github.io/post/what-is-lazy-evaluation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://htrekker.github.io/post/what-is-lazy-evaluation/</guid>
      <description>例如5+3的值为8。我们的大脑也是这种及早求值：每当有人跟你说，“她真是个厉害的程序员！”。如果&amp;hellip;
 本文翻译自What is Lazy Evaluation? — Programming Word of the Day 欢迎关注原作者！
 当编译器遇到一个表达式时，通常都要尝试去计算这个表达式的值。
例如5+3的值为8。我们的大脑也是这种及早求值：每当有人跟你说，“她真是个厉害的程序员！”。如果“她”已经在之前的对话中提到过，那么你的大脑就会将“她”这个代词指向那个人（求值）。
虽然，大部分语言都使用这种及早求值的方式，但这种方式并不是很高效。因为，并不是所有的表达式都有计算的价值。例如，一个函数的参数可能不会被使用，所以我们更没有必要计算它们。
def somFunction(x, y) = return x + 1 someFunction(3, 3 + 2) 在上面这个例子中，计算表达式3+2的值是没有任何意义的。因为，它根本就没有被使用过。==只计算需要的值的这种计算方式被称作惰性求值，与之相反的方式（立即计算表达式）被称作及早求值==
惰性求值之所以称为“惰性”是因为编译器得了”拖延症“。这种编译器不会成为一个好学生或者提前预习的学生。相反，它只会推迟对表达式的计算，直到真正的需要这个表达式的值时。就好像计算完之后他就会说：”唉，好吧。我算还不行吗！(╯‵□′)╯︵┻━┻“
就像一个懒惰的学生一样，一个”懒惰“的编译器的效率会高很多 如果想要惰性求值变得更高效，它需要使用记忆化。换句话说就是，编译器需要在内存中创建一个字典。这个字典的键就是这个变量的名字，键对应的值就是这个表达式的计算结果。当编译器遇到一个已经被计算好的变量时，它只需要简单的在这个字典中查找出其所对应的值即可。
 除了在性能上的优势以外，惰性求值还有以下几个特点，是得它非常的有趣。大多数的编程语言有一种所谓的短路行为用于优化布尔运算。例如，当一个
短路行为往往被硬编码到编译器当中，他们都有一些特定的代码去执行这种逻辑。但是，有了惰性求值就在不再需要这种硬编码。这使得编译器变得更简单并且更容易理解。你可以将
 惰性求值另一个很有趣的“副产物”是：惰性求值可以计算无穷列表。在一个正常的编译器中，无穷列表这个概念实际上并不存在。因为编译器总是想尽早的计算表达式，所以编译器会真的尝试去计算一个无穷列表。这回导致内存被耗尽，从而程序无法正常运行。
另外，一个具备惰性求值的编译器只会去计算一定用得到的表达式的值。即使你定义了一个无穷列表，但这个无穷列表实际上并不需要全部计算其值。一个无穷列表看上去类似于：
def addOne(n) = [n] + addOne(n + 1) // [1, 2, 3, 4, 5, 6, ...] list = addOne(1) addOne会递归地将它的参数添加到这个列表中。这个递归式不会有终止条件：它会永远的运行下去。
之后我们可以定义一个无穷列表，这个列表的将会是上面这个函数当参数为1时的返回值。当我们不真正计算这个无穷列表的值时，这段代码目前并不会崩溃。你也许会问了：”既然我们没法用这个列表，那么我为什么还要定义它？“虽然，我们不能使用整个列表，但是我们可以使用它的一部分！
oneToThree = list.takeFirst(3) print(oneToThree) // [1, 2, 3] def range(start, end) = list.</description>
    </item>
    
  </channel>
</rss>